using JuMP
import Ipopt

include("sol_data.jl")


model = Model(Ipopt.Optimizer)

#
# VARIABLES
#

# Phase
@variable(model, theta_min <= theta[i = 1:n] <= theta_max)

# Voltage amplitude [v.u]
@variable(model, v_min <= v[i = 1:n] <= v_max)

# Active power generated by generator i
@variable(model, 0 <= P_G[i = 1:n_G] <= M[i])

# Reactive power generated by generator i 
@variable(model, -L * M[i] <= Q_G[i = 1:n_G] <= L * M[i])


#
# OBJECTIVE
#

@objective(model, Min, sum(c[i] * P_G[i] for i in 1:n_G))


# 
# CONSTRAINTS
# 

active_constraints = @NLconstraints(model, begin
    [i = 1:n], (
        sum(
            E_G[i, j] * P_G[j] for j in 1:n_G
        ) - sum(
            E_C[i, j] * D[j] for j in 1:n_C
        ) 
        == 
        sum(
            (
                + v[i]^2 * g[i, j] 
                - v[i] * v[j] * g[i, j] * cos(theta[i] - theta[j])
                - v[i] * v[j] * b[i, j] * sin(theta[i] - theta[j])
            )  for j in 1:n
        ) - sum(
            (
                + v[j]^2 * g[j, i] 
                - v[j] * v[i] * g[j, i] * cos(theta[j] - theta[i])
                - v[j] * v[i] * b[j, i] * sin(theta[j] - theta[i])
            ) for j in 1:n
        )
    )
end)

# Reactive 
reactive_constraints = @NLconstraints(model, begin
    [i = 1:n], (
        sum(
            E_G[i, j] * Q_G[j] for j in 1:n_G
        ) 
        == 
        sum(
            (
                - v[i]^2 * b[i, j] 
                + v[i] * v[j] * b[i, j] * cos(theta[i] - theta[j])
                - v[i] * v[j] * g[i, j] * sin(theta[i] - theta[j])
            )  for j in 1:n
        ) - sum(
            (
                - v[j]^2 * b[j, i] 
                + v[j] * v[i] * b[j, i] * cos(theta[j] - theta[i])
                - v[j] * v[i] * g[j, i] * sin(theta[j] - theta[i])
            ) for j in 1:n
        )
    )
end)


#
# RUN
#

optimize!(model)


function p(v_k, v_l, theta_k, theta_l, g_kl, b_kl)
    return (
        + v_k^2 * g_kl
        - v_k * v_l * g_kl * cos(theta_k - theta_l)
        - v_k * v_l * b_kl * sin(theta_k - theta_l)
    ) 
end

function q(v_k, v_l, theta_k, theta_l, g_kl, b_kl)
    return (
        - v_k^2 * b_kl 
        + v_k * v_l * b_kl * cos(theta_k - theta_l)
        - v_k * v_l * g_kl * sin(theta_k - theta_l)
    ) 
end

p_hat = zeros(n, n)
q_hat = zeros(n, n)

v_val = JuMP.value.(v)
theta_val = JuMP.value.(theta)

for k in 1:n
    for l in 1:n
        p_hat[k, l] = p(v_val[k], v_val[l], theta_val[k], theta_val[l], g[k, l], b[k, l])
        q_hat[k, l] = q(v_val[k], v_val[l], theta_val[k], theta_val[l], g[k, l], b[k, l])
    end
end



#
# DISPLAY
#

println("")
println("Optimal Solution:") 
println("")
println("Termination statue: ")
display(JuMP.termination_status(model))
println("")
println("Cost across each node: f [sek]")
display(JuMP.objective_value(model))
println("")
println("Active power generated in each generator: P_G [pu]")
display(JuMP.value.(P_G))
println("")
println("Net reactive power generated in each generator: Q_G [pu]")
display(JuMP.value.(Q_G))
println("")
println("Voltage amplitudes: v [vu]")
display(JuMP.value.(v))
println("")
println("Phase values: theta")
display(JuMP.value.(theta))
println("")
println("Active power flow from node k to l: p [pu]")
display(p_hat)
println("")
println("Reactive power flow from node k to l: q[pu]")
display(q_hat)
println("")